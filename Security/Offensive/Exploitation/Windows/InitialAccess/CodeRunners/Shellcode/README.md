# Developing Shellcode

## Definition
Shellcode is portable native code that can be run in any place in memory. 

### Byte-Free Shellcode
In some cases your code will terminate prematurely. One way to fix this is to avoid using a `null` byte altogether.  The following table shows common instructions, what they look like in binary, and their null-free equivalents.

| Null-Byte Instruction | Binary Form | Null Free Instruction | Binary Form |
| --------------------- | ----------- | --------------------- | ----------- |
| mov eax,5 | B8 00000005 | mov al,5    | B0 05 |
| call next | E8 00000000 | jmp next/call prev  | EB 05/ E8 F9FFFFFF |
| cmp eax,0 | 83F8 00 | test eax,eax    | 85C0 |
| mov eax,0 | B8 00000000 | xor eax,eax | 33C0 |

### Alphanumeric Shellcode
To bypass filters, IDS, AV you may need to restrict yourself to specific characters which will require you to limit bytes to a specific range.

### Buffer sizes
In an "off by one" vulnerability you may only be able to send a single shellcode. In this case you would use 2 buffers. 1 for the shellcode and the 2nd for attacking and searching the first.

## Anatomy
1. Getting Delta
Knowing where you are in memory is essential when retrieving variables in shellcode. You will need the absolute address.

To get the delta you can use a call-pop sequence to get the Extended Instruction Pointer (EIP). 
While executing the call the processor:
    - Saves and returns the EIP in the stack
    - Pop register will get the EIP from the stack to register.
    - Result is pointer inside shellcode
```asm
GETDELTA:
    call NEXT
NEXT:
    pop ebx
```

2. Kernel32 Imagebase
To reach any API you must first get the address of kernel32.dll .

Process Environment Block(PEB)
While any application is being loaded in memory, windows saves the address of libraries `kernel32.dll`, `ntdll.dll` in a place in memory called the PEB. 

### Get the PEB Address:

```asm
mov eax,dword ptr fs:[30h]
```
- `eax` will contain the pointer to the PEB.
- `fs` FS segment register. 
- 30hex (48 bytes) is the offset 
- Returns pointer to the PEB
- The `mov` instruction will have null bytes

The [PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb) will be located at a predictable offset `fs:[0x30]` on 32 bit and `gs:[0x60]` on 64 bit.
```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

Within the PEB is the [PEB_LDR_DATA](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data) structure, which has a list of every module loaded into the process (including the process itself).

```cpp
  BYTE                          Reserved1[2];  // 00
  BYTE                          BeingDebugged; // 01
  BYTE                          Reserved2[1]; // 04
  PVOID                         Reserved3[2]; // 08
  PPEB_LDR_DATA                 Ldr; // 0C (12)
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters; // 10
  PVOID                         Reserved4[3]; // 14
  PVOID                         AtlThunkSListPtr; // 18
  PVOID                         Reserved5; // 1C
  ULONG                         Reserved6; // 20
```

To access the LDR Data you will need to use an offset from your PEB
```asm
mov eax, dword ptr fs:[0x30] // PEB Address Pointer
mov eax, dword ptr [eax+0Ch] // LDR (PEB + 12 bytes) 
```
- The current base address + an offset of `0Ch` (12 bytes) 
- `[]` indicates that the value at the calculated address is to be accessed not the address itself.

The PEB LDR Data will give us 3 double-linked lists. These lists are typically at a preset location:

1. InLoadOrderModuleList (0x0C) - Modules in load order
2. InMemoryOrderModuleList (0x14) - Modules in memory layout order
3. InInitializationModuleList (0x1C) - Modules in initialization order

```cpp
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8]; 
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList; 
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```

`InMemoryOrderModuleList` is a double linked lists containing 3 parts:
1. Data being stored
2. Next pointer (FLink) - points to the next item in the list
3. Previous pointer (BLink) - points to the previous item in the list

To now access `InMemoryOrderModuleList` we need to access it from the offset `0x1C`. This will give use the FLink which is the first entry in the module list.

The first entry is typically `ntdll.dll`, but this can change for a variety of reasons. (honeypot dlls)

```asm
mov eax, dword ptr fs:[0x30] // PEB Address Pointer
mov eax, dword ptr [eax+0x0C] // LDR
mov ebx, dword ptr [eax+0x1C] // InMemoryOrderModuleList, FLink, ntdll.dll
```

To traverse the list, access the offset. Offset 0 will move it forward:
```asm
mov eax, dword ptr [ebx] 		; FLink offset 0, move forward to kernel32.dll

mov eax, dword ptr [ebx + 0x04] ; Offset 4, move backwards.
mov eax, dword ptr [ebx + 0x08] ; Offset 8, DLL base / data we want.
mov eax, dword ptr [ebx + 0x10] ; Offset 16, DLL base / data we want.
```

As a final step, we will return the image base for kernel32.dll
```asm
mov eax, dword ptr fs:[0x30] 	; PEB Address Pointer
mov eax, dword ptr [eax+0x0C] 	; LDR
mov ebx, dword ptr [eax+0x1C] 	; InMemoryOrderModuleList, FLink, (ntdll.dll)
mov ebx, dword ptr [ebx] 		; Move to kernel32.dll
mov esi, dword ptr [ebx+0x08] 	; Return image base of kernel32.dll
```

## 3. Walking the PE Structure
The PE structure provides core API functionality such as memory management and process creation.

The export table consists of 3 arrays:

AddressOfNames (4 bytes) -> AddressOfNamesOrdinals (2 bytes) -> AddressOfFunctions (4 bytes)

The `AddressOfNames` will not match 1 to 1 in the `AddressOfFunctions`. To reliably match, we will need to use the `AddressOfNamesOrdinals`.

1. Search for API Name in `AddressOfNames` and store the returned index
2. Use `AddressOfNameOrdinals` to find the index of the API
3. Use the index of the API to get the address of the API

Note that all these addresses are RVA, and are relative to the address of the begining of the PE file. In our case this is kernel32.dll

We'll start by creating a `Procedure` labeled `GetAPIs` and setting a few local variables.
```asm
GetAPIs Proc
	Local AddressFunctions:DWord
	Local AddressOfNameOrdinals:DWord
	Local AddressNames:DWord
	Local NumberOfNames:DWord
```

Get the PE Header. This involves creating another label (but no procedure) 
```asm
Getting_PE_Header:
	mov edi, esi	; Kernel32.dll image base
	mov eax, [esi].IMAGE_DOS_HEADER.e_lfanew ; [esi + 0x3C] offset from base. This is where the NT headers start
	mov esi, edi	; Points to `IMAGE_NT_HEADERS`
```

The export table will give us the virtual address:
```asm
Getting_Export_Table:
	mov eax, [esi].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[0].VirtualAddress
	add eax, edi ; add the virtual address to the kernel base 
	add esi, eax ; contains the pointer to the (NT_HEADERS + virtual address location)
```

We will need to get 3 arrays:
```asm
Getting_Arrays:
	mov eax, [esi].IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
	add eax, edi
	mov AddressFunctions, eax ; 1st array

	mov eax, [esi].IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals
	add eax, edi
	mov AddressOfNameOrdinals, eax ; 2nd array

	mov eax, [esi].IMAGE_EXPORT_DIRECTORY.AddressOfNames
	add eax, edi
	mov AddressOfNames, eax ; 3rd array

	mov eax, [esi].IMAGE_EXPORT_DIRECTORY.NumberOfNames
	mov NumberOfNames, eax; Count of APIs

	push esi; 
	mov esi, AddressOfNames
	xor ecx, ecx ; clear register
```	

Get the APIs
```asm
GetTheAPIs:
	lodsd ; load 4byte value pointed by esi
	push esi
	lea esi, [eax + edi]	; Load Effective Address RV + imagebase = Virtual Address
	xor edx; clear 
	xor eax; clear
```

```asm
ChecksumCalc:
	Lodsb				; load 4 bytes pointed to by `esi`
	test eax, eax		; avoid null bytes, effecient way to check if zero
	jz CheckFunction 	; jump if zero to CheckFunction
	add edx,eax
	xor edx, eax		; clear
	inc edx 			; increment by 1 
	jmp ChecksumCalc
```

This function will compare the first 4 bytes of an api to our desired apis. 
```asm
CheckFunction:
	pop esi				; copties 4 byte values pointer to from `esp` to `esi`
	xor eax eax			; index of this api
	cmp edx, 0AAAAAAAAH ; First API
	jz FoundAddress		; jump if zero (matches 4byte hash value)
	cmp edx, 0BBBBBBBBh ; Second API
	inc eax
	jz FoundAddress		
	cmp edx, 0CCCCCCCCh	; Third API
	inc eax
	jz FoundAddress
	xor eax, eax
	inc ecx
	cmp ecx,NumberOfNames
	jz EndFunc
```

Each entiry in the name ordinals array is 2 bytes (word 16 bits)
```asm
jmp GetTheAPIs
FoundAddress:
	mov edx, esi								; save temporarily
	pop esi										; esi -> PE header
	push eax									; save index of API
	mov eax, AddressOfNameOrdinals				 
	movzx ecx, word ptr [eax + ecx * 2] 		; move with zero-extend takes a 16bit value and pads a 32bit value with zeros
	mov eax, AddressFunctions
	mov eax, dword ptr [eax + ecx * 4]			
	add eax, edi
	pop ecx										; get index of API
	mov [ebx + ecx * 4], eax
	push esi
	mov esi, edx
	jmp GetTheAPIs
EndFunc:
```

Portions of this script have been split up. Full script is here
	
4. Payload

## Tools to explore 
1. Easy Code MASM 
- Visualizer
- IDE
- Code completion

2. OllyDbg
- Debugger
- Assembler

3. Data Ripper
- Plugin for OllyDbg
- Helps with porting to exploit dev


We will need to dynamically locate functions and then call them.

1. Locate `Kernel32.dll`
To locae the base address of `kernel32.dll` we will need to traverse the Process Environment Block (PEB) and the Thread Environment Block (TEB).

2. Load `user32.dll` using `LoadLibraryA` into the process address space

3. Use `GetProcAddress` to locate `MessageBoxA`

```asm
; Load user32.dll

push 0x00000000     ; NULL terminator
push 0x6C6C642E     ; ".dll"
push 0x32337265     ; "er32"
push 0x7375         ; "us"
mov eax,esp         ; lpFileName = "user32.dll" 
push eax
call [LoadLibraryA_Address] ; Load user32.dll

; Find MessageBoxA
push 0x00000000         ;MB_OK
push CaptionStringAddress
push HelloWorldAddress
push 0x00000000         ;hWnd = NULL
call [MessageBoxA_Address]
