# Memory Management
The `ESP` (Extended Stack Pointer) always points to the top of the stack in memory.

`push` - ESP is decremented
`pop` - ESP is incremented

Consider the following hello world program:

```asm
section .data
    message: 
        DB 'Hello world',0xA;

section .text
    _main: 
        call _printf
        add esp,4
        ret
```

## Explaination

### Code Organization
The following 2 lines are used for memory optimization and organization:
1. `section .data` 
- Store initialized data
- Global or static variables that have an initial value
- Embedded in the final `.exe`

2. `section .text`
- Contains machine instructions.

### (DB) Define Byte
Allocates memory space in the data segment and initialize that space with the specific bytes values provided.
```asm
message:
    DB 'Helloworld' 0xA,0;
```

`printf` expects a pointer to a sequence of bytes and will keep reading and printing those bytes until it encounters the `0`. `DB` provides the correct format.

- `0xA` - New line 

### Memory clean up
Standard C calling convention dictates that the function calling another function is responsible for removing the arguments from the stack after the called function returns. `_main`

`_printf` knows to read 4 bytes of data from the stack because it expects a pointer argument. When it completes and returns control to `_main` the 4 bytes of the address are still on the stack.

After pushing `message` to the stack, move the pointer back 4 bytes which effectively de-allocates it.
- In 32-bit systems registers like `ESP` are 32 bits.
- Memory addresses are 32 bits long
- 32 bits / 8 bits = 4 bytes.

```asm
push message
call _printf
add esp,4
```
