# UnsafeNativeMethods
The [Add type method](./add-type-method.md) `Add-Type` calls the csc compiler which writes to 2 temporary files to disk increases the chance of detection. We will want to do a dynamic lookup instead.

| Functions | Description |
| --------- | ----------- |
| `GetModuleHandle` | Obtains handle (memory address ) of the DLL. | 
| `GetProcAddress` | Pass the DLL handle and return function address.| 

## Dynamic Lookups
Create the .NET assembly in memory instead of writing code and compiling it by leveraging existing assemblies. 

### Locate existing assembilies 
The following code block does:
- Search preloaded assemblies in the Powershell process.
- Location prints current assembly location
- GetTypes will return the types defined in the assembly
- $_ is the current object 
- Filter by Static Methods
- Where Object equals our unsafe method string

```ps
$Assemblies = [AppDomain]::CurrentDomain.GetAssemblies()

$Assemblies | ForEach-Object {
    $_.$Location $_.GetTypes() | ForEach-Object { 
        $_ | Get-Member -Static | Where-Object { $_.TypeName.Equals('Microsoft.Win32.UnsafeNativeMethods') }
    } 2> null
}
```

### Invoke By Reference
These methods are only meant to be used internally, and will be blocked from being called directly from Powershell or C#. We can circumvent this by obtaining a reference to the System.dll assembly using the GetType method.

```sh
$systemdll = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {
    $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
});

$UnsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods');
$GetModuleHandle = $UnsafeObj.GetMethod('GetModuleHandle');
$GetProcAddress = $UnsafeObj.GetMethod('GetProcAddress');

$GetModuleHandle.Invoke($null, @("user32.dll"));
```

This will return a memory address, which we can then verify using process explorer:

```ps
'0x{0:X}' -f 140729182191616

# 0x00007FFE10EA0000
```

### GetMethods
If you receive an error "Ambiguous match found." It means that there are multiple instances of the method you are looking for. This can be solved by using `GetMethods`
```ps
$temp = @()
$UnsafeObj.GetMethods() | Foreach-Object {
    if ($_.Name -eq "GetProcAddress") {
        $temp+=$_
    }
}
$GetProcAddress = $tmp[0]
$GetProcAddress.Invoke($null, @('user32', "MessageBoxA"))
```

## Lookup Function
All the above can be simplified into the following lookup function:
```ps
function LookupFunc 
{
	Param (
		[string] $moduleName, 
		[string] $functionName
	)

	$assemembly = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
			$_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') 
		}
	).GetType('Microsoft.Win32.UnsafeNativeMethods')
	$tmp=@()
	$assembly.GetMethods() | ForEach-Object {
			If ($_.Name -eq "GetProcAddress") {
			$tmp+=$_
		}
	}
	return $tmp[0].Invoke($null, @(($assembly.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

$MessageBoxA = LookupFunc user32.dll MessageBoxA
```

## Get Delegate Type
```psh
function GetDelegateType {
    param(
        [Parameter(Position = 0, Mandatory=$true)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    $MyAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
    $Domain = [AppDomain]::CurrentDomain
    $MyAssemblyBuilder = $Domain.DefineDynamicAssembly($MyAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
    $MyModuleBuilder = $MyAssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)

    $MyTypeBuilder = $MyModuleBuilder.DefineType(
        'MyDelegateType', 
        'Class, 
        Public, 
        Sealed, 
        AnsiClass, 
        AutoClass', 
        [System.MulticastDelegate]
    )
    $MyConstructorBuilder = $MyTypeBuilder.DefineConstructor(
        'RTSpecialName, 
        HideBySig, 
        Public', 
        [System.Reflection.CallingConventions]::Standard, 
        $func
    )
    $MyConstructorBuilder.SetImplementationFlags('Runtime, Managed')
    $MyMethodBuilder = $MyTypeBuilder.DefineMethod(
        'Invoke', 
        'Public, 
        HideBySig, 
        NewSlot, 
        Virtual', 
        $delType, 
        $func
    )
    $MyMethodBuilder.SetImplementationFlags('Runtime, Managed')
    return $MyTypeBuilder.CreateType()

}
```

## Usage
Check the documentation in order to pass function parameters
- You'll want to call VirtualAlloc and CreateThread instead of the MessageBoxA
```psh
$MessageBoxAAddr = LookupFunc user32.dll MessageBoxA
$MessageBoxADelegateType = GetDelegateType @([IntPtr], [string], [string], [int])
$MessageBoxA = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($MessageBoxAAddr, $MessageBoxADelegateType)
$MessageBoxA.Invoke([IntPtr]::Zero, "Caption", "Hello there!", 0)
```
