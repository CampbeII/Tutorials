# Translate Windows APIs to Powershell
This is easily done using [P/Invoke](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke). Must be imported through the `using` directive keyword.

## Helpful Tools
- [https://github.com/microsoft/CsWin32](https://github.com/microsoft/CsWin32)
- [https://www.pinvoke.net](https://www.pinvoke.net)

## 1. Read Function Documentation:

Original Syntax for `MessageBox` from `User32.dll`
```sh
int MessageBox(
    HWND    hWnd,
    LPCTSTR lpText,
    LPCTSTR lpCaption,
    UINT    uType
);
```

## 2. Translated Signature:
Using any of the above tools, determine the translated signature for the function:
```pwsh
[DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
public static extern int MessageBox(int hWnd, String text, String caption, uint type);
```

Import the namespaces:
```pwsh
using System;
using System.Runtime.InteropServices;
```

Create a C# class (User32) which imports the signature with DllImport.
```pwsh
public class User32 {
    [DllImport("user32.dll",CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
```

## 3. Create heredoc string
Invoke from Powershell using the `Add-Type` keyword. This will force `.NET` to complie and create an object containing our code inside the `Add-Type` statement. 

```pwsh
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
"@

Add-Type $User32
```

## 4. Execute API
We will do this by instantiating the `User32.NET` object at the end of our code:
```pwsh
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
"@

Add-Type $User32

[User32]::MessageBox(0,"This is a test","MyBox",0)
```

## 5. UnsafeNativeMethods
Our original technique used `Add-Type` and `DllImport`. However, `Add-Type` calls the csc compiler which writes to disk. We will want to do a dynamic lookup instead.

1. GetModuleHandle
- Obtains a handle to the specified DLL which is the memory address of the DLL. 

2. GetProcAddress
- Find the address of a specific function by passing the DLL handle and the function name. Returns the function address.

## 6. Dynamic Lookups
Create the .NET assembly in memory instead of writing code and compiling it.  We cannot create new assemblies, but we can leverage existing ones.

### Locate existing assembilies 
The following code block does:
- Search preloaded assemblies in the Powershell process.
- Location prints current assembly location
- GetTypes will return the types defined in the assembly
- $_ is the current object 
- Filter by Static Methods
- Where Object equals our unsafe method string

```ps
$Assemblies = [AppDomain]::CurrentDomain.GetAssemblies()

$Assemblies | ForEach-Object {
    $_.$Location $_.GetTypes() | ForEach-Object { 
        $_ | Get-Member -Static | Where-Object { $_.TypeName.Equals('Microsoft.Win32.UnsafeNativeMethods') }
    } 2> null
}
```

### Invoke By Reference
These methods are only meant to be used internally, and will be blocked from being called directly from Powershell or C#. We can circumvent this by obtaining a reference to the System.dll assembly using the GetType method.

```sh
$systemdll = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {
    $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
});

$UnsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods');
$GetModuleHandle = $UnsafeObj.GetMethod('GetModuleHandle');
$GetProcAddress = $UnsafeObj.GetMethod('GetProcAddress');

$GetModuleHandle.Invoke($null, @("user32.dll"));
```

### Verify Results
The invoke method will return an integer:
```sh
$address = 140726048522240;
```

Translate to hexadecimal
```sh
$hex = $address.ToString('X');
```

Using Process Explorer
- Click View
- Lower Pane View
- DLLs
- Double click user32.dll
- The 2 values should match

## Ambiguous match found
Occurs when there are multiple instances of the method. We'll need to use `GetMethods` and then filtering by name.
```sh
$UnsafeObj.GetMethods() | ForEach-Object {
    If($_.Name -eq "GetProcAddress") {
        $_
    }
}
```

### Completed Lookup Function
This example will be used to return the memory address of a function.
```sh
function LookupFunc {
    Param(
        $moduleName,
        $functionName
    );
    $a = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {
    	$_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
    }).GetType('Microsoft.Win32.UnsafeNativeMethods');

    $tmp = @();
    $a.GetMethods() | Foreach-Object {
        If($_.Name -eq "GetProcAddress") {
            $tmp+=$_
        }
    }
    return $tmp[0].Invoke($null, @(($a.GetMethod('GetModuleHandle')).Invoke($null,@($moduleName)), $functionName));
}

$msg = LookupFunc 'user32.dll' MessageBoxA
```

### DelegateType Reflection
The next step is to define the argument types.
- number of arguments and data types must be paired with the resolved function memory address.
- C# uses the `GetDelegateForFunctionPointer` method and takes 2 args: mem address, function prototype as a type.
```c
int delegate MessageBoxSig(IntPtr hWind, String text, String caption, int options);
```

In Powershell a delegate type is created when the assembly is compiled. We will want to manually create an assembly in memmory and populate it with content.

1. Create new assembly object through the AssemblyName class and name it ReflectedDelegate.
```ps
$A = New-Object System.Reflect.AssemblyName('ReflectedDelegate');
```

2. Configure Access Mode
- Executable and not saved to disk
- Acheived through `DefineDynamicAssembly` method by supplying the custom assembly name.
- Set as executable by supplying the `Run` access mode value.
```ps
$Domain = [AppDomain]::CurrentDomain;
$AssemblyBuilder = $Domain.DefineDynamicAssembly($A, [System.Reflection.Emit.AssemblyBuilderAccess]::Run);
```

3. Create Content
Modules are the buliding blocks of an assembly. Create a module through the `DefineDynamicModule` Method
- Supply custom name
- Don't include symbol information
```ps
$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule',$false);
```

4. Create Custom Type
Create the type that will become our delegate type using `DefineType`
- Set the custom name `MyDelegateType`
- Combined list of attributes for the type: Class, Public, AnsiClass, AutoCLass
- MulticastDelegateClass allows a delegate type with multiple entries which all us to call the target api with multiple arguments.

```ps
$TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]);
```

5. Define Constructor
This will take 3 arguments:
- Attributes of the constructor 
- Defines how args and return values are handled. We choose default.
- Define parameter types
```ps
$ConstructorBuilder = $TypeBuilder.DefineConstructor(
	'RTSpecialName, HideBySig, Public',
	[System.Reflection.CallingConventions]::Standard,
	@([IntPtr], [String], [String], [int])
);
```

6. Call the constructor
- set implementation flags
```ps
$ConstructorBuilder.SetImplementationFlags('Runtime, Managed');
```

7. Define the Invoke Method
Using `DefineMethod` we will create the settings for the invoke method.
- name of method 
- method attributes ensure that it is virtual and always gets a new slot in the vtable.
- Return type of the function 
- Array of arg types thta were defined above

```ps
$MethodBuilder = $TypeBuilder.DefineMethod(
	'Invoke', 
	'Public HideBySig, NewSlot, Virtual', 
	[int],
	@([IntPtr],[String],[String],[int])
);
$MethodBuilder.SetImplementationFlags('Runtime, Managed');
```

8. Call our custom constructor
```ps
DelegateType = TypeBuilder.CreateType();
```	

## Completed Code
```ps
function LookupFunc {
	Param (
		$ModuleName,
		$FunctionName
	);
	$A = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { 
		$_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')
	}).GetType('Microsoft.Win32.UnsafeNativeMethods');

	$tmp = @();
	$A.GetMethods() | ForEach-Object {
		If ($_.Name -eq "GetProcAddress") {
			$tmp += $_
		}
	}
	return $tmp[0].Invoke($null, @(($A.GetMethod('GetModuleHandle')).Invoke($null, @($ModuleName)), $FunctionName));
}

$MessageBoxA = LookupFunc user32.dll MessageBoxA
$Assembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate');
$Domain = [AppDomain]::CurrentDomain;

$AssemblyBuilder = $Domain.DefineDynamicAssembly($Assembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run);
$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false);
$TypeBuilder = $ModuleBuilder.DefineType('DelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate]);

$ConstructorBuilder = $TypeBuilder.DefineConstructor(
	'RTSpecialName, HideBySig, Public',
	[System.Reflection.CallingConventions]::Standard,
	@([IntPtr],[String],[String],[int])
);
$ConstructorBuilder.SetImplementationFlags('Runtime, Managed');

$MethodBuilder = $TypeBuilder.DefineMethod(
	'Invoke', 
	'Public, HideBySig, NewSlot, Virtual',
	[int],
	@([IntPtr],[String],[String],[int])
);
$MethodBuilder.SetImplementationFlags('Runtime,Managed');
$DelegateType = $TypeBuilder.CreateType();

$MyFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($MessageBoxA, $DelegateType);
$MyFunc.Invoke([IntPtr]::Zero, "Hello World", "This is the message box", 0);
```

## Modifying it for another function.
1. Perform the lookup:
```ps
$WinExec = LookupFunc kernel32.dll WinExec
```

2. Use Pinvoke to determine the new paramaters and put them in both the constructor and the type:
```ps
$ConstructorBuilder = $TypeBuilder.DefineConstructor(
	'RTSpecialName, HideBySig, Public',
	[System.Reflection.CallingConventions]::Standard,
	@([String],[int])
);
$ConstructorBuilder.SetImplementationFlags('Runtime, Managed');

$MethodBuilder = $TypeBuilder.DefineMethod(
	'Invoke', 
	'Public, HideBySig, NewSlot, Virtual',
	[int],
	@([String],[int])
);
```

3. Invoke the function:
```ps
$MyFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WinExec, $DelegateType);
$MyFunc.Invoke("C:\\Windows\\Notepad.exe",5);
```

## Modifying for x64
The following changes need to be done when running this code on x64
- All PInvoke signatures that reference `UInt32` need to be changed to `IntPtr` or `UInt64`
