$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
"@

Add-Type $User32

[User32]::MessageBox(0,"This is a test","MyBox",0)



Import the namespaces:
```pwsh
using System;
using System.Runtime.InteropServices;
```

Create a C# class (User32) which imports the signature with DllImport.
```pwsh
public class User32 {
    [DllImport("user32.dll",CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
```

## 3. Create heredoc string
Invoke from Powershell using the `Add-Type` keyword. This will force `.NET` to complie and create an object containing our code inside the `Add-Type` statement. 

```pwsh
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
"@

Add-Type $User32
```

## 4. Execute API
We will do this by instantiating the `User32.NET` object at the end of our code:
```pwsh
$User32 = @"
using System;
using System.Runtime.InteropServices;

public class User32 {
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);
}
"@

Add-Type $User32

[User32]::MessageBox(0,"This is a test","MyBox",0)
```

